<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>五子棋 - 网页小游戏</title>
  <style>
    :root {
      --board-size-raw: min(70vw, 80vh);
      --board-size: clamp(400px, var(--board-size-raw), 720px);
      --label-width: 64px;
      --gap-size: 12px;
      --panel-bg: #fff9f0;
      --accent: #c77b30;
      --text-dark: #2f2f2f;
      --panel-shadow: 0 12px 28px rgba(76, 52, 26, 0.16);
      --status-bg: #fff2de;
      --message-bg: #fff4d3;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      padding: 0 16px 48px;
      font-family: "PingFang SC", "Microsoft YaHei", sans-serif;
      background: radial-gradient(circle at top, #fffdf1, #f2e2cf);
      color: var(--text-dark);
      min-height: 100vh;
    }
    h1 {
      text-align: center;
      margin: 24px auto 12px;
      letter-spacing: 6px;
      color: #4a331c;
      font-weight: 600;
    }
    main.page-wrapper {
      width: min(1200px, 100%);
      margin: 0 auto 40px;
      display: flex;
      flex-wrap: wrap;
      gap: 32px;
      justify-content: center;
      align-items: flex-start;
    }
    .board-section {
      flex: 1 1 560px;
      min-width: 420px;
      display: flex;
      justify-content: center;
    }
    .board-wrapper {
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: flex-start;
    }
    .top-row {
      display: flex;
      align-items: center;
      gap: var(--gap-size);
    }
    .corner-placeholder {
      width: calc(var(--label-width) + var(--gap-size));
      height: 1px;
    }
    .col-labels {
      display: grid;
      grid-template-columns: repeat(15, 1fr);
      width: var(--board-size);
      padding: 0 10px;
      font-weight: 600;
      color: #7a5b2c;
      letter-spacing: 2px;
    }
    .col-labels span {
      text-align: center;
    }
    .board-row {
      display: flex;
      gap: var(--gap-size);
      align-items: stretch;
    }
    .row-labels {
      width: var(--label-width);
      height: var(--board-size);
      padding: 10px 6px;
      display: grid;
      grid-template-rows: repeat(15, 1fr);
      background: rgba(255, 255, 255, 0.35);
      border-radius: 10px;
      box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.08);
    }
    .row-labels span {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      font-weight: 600;
      color: #7a5b2c;
    }
    .board-container {
      width: var(--board-size);
      min-width: 400px;
      aspect-ratio: 1 / 1;
      border: 10px solid #b9823c;
      border-radius: 16px;
      background: #f8e0b2;
      position: relative;
      box-shadow: 0 16px 35px rgba(0, 0, 0, 0.18);
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: pointer;
      border-radius: 6px;
    }
    .control-panel {
      flex: 0 0 320px;
      min-width: 280px;
      background: var(--panel-bg);
      border-radius: 24px;
      padding: 28px 28px 24px;
      box-shadow: var(--panel-shadow);
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    .control-panel h2 {
      margin: 0;
      font-size: 1.6rem;
      font-weight: 700;
      color: #4b2806;
      letter-spacing: 3px;
    }
    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    label {
      font-weight: 600;
      color: #5d4323;
    }
    select,
    button {
      width: 100%;
      padding: 12px 14px;
      font-size: 1rem;
      border-radius: 14px;
      border: 2px solid #e7c8a1;
      background: #fff9f1;
      color: var(--text-dark);
      transition: transform 0.18s ease, box-shadow 0.18s ease, background 0.18s ease;
    }
    select:focus,
    button:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(199, 123, 48, 0.2);
    }
    .button-group {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    .button-group button {
      flex: 1 1 150px;
      min-width: 150px;
      width: auto;
    }
    button {
      font-weight: 600;
      background: linear-gradient(120deg, #f3c88f, #e5a55e);
      color: #4c2b06;
      border: none;
      cursor: pointer;
    }
    button:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 18px rgba(61, 32, 3, 0.25);
    }
    button:active:not(:disabled) {
      transform: translateY(0);
      box-shadow: inset 0 2px 6px rgba(0, 0, 0, 0.2);
    }
    button:disabled {
      background: #e1d3c1;
      color: #8f8270;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }
    .status-card {
      background: #fff7ea;
      border: 1px solid rgba(92, 59, 23, 0.12);
      border-radius: 18px;
      padding: 16px 18px;
      line-height: 1.6;
      font-size: 0.95rem;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .status-card p {
      margin: 0;
    }
    .status-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 8px 12px;
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.55);
    }
    .status-row .status-label {
      font-weight: 600;
      color: #5c3b17;
      flex-shrink: 0;
    }
    .status-row .status-value {
      color: #7d6240;
      text-align: right;
      flex: 1;
    }
    .status-row.is-finished {
      background: rgba(255, 203, 143, 0.35);
      border: 1px solid rgba(199, 123, 48, 0.4);
    }
    .status-row.is-finished .status-value {
      font-weight: 700;
      color: #a15000;
      background: rgba(255, 255, 255, 0.7);
      padding: 4px 10px;
      border-radius: 999px;
      display: inline-flex;
      justify-content: center;
    }
    .ai-status-wrap {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .ai-loader {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 2px solid rgba(199, 123, 48, 0.2);
      border-top-color: #c77b30;
      animation: spin 0.8s linear infinite;
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    .ai-status-wrap.thinking .ai-loader {
      opacity: 1;
    }
    .message-bar {
      min-height: 48px;
      padding: 14px 16px;
      background: var(--message-bg);
      border-radius: 14px;
      border: 1px dashed rgba(199, 123, 48, 0.4);
      line-height: 1.5;
      font-size: 0.92rem;
      color: #6b4c2b;
      opacity: 0.92;
      transition: opacity 0.4s ease;
    }
    .message-bar.message-flash {
      animation: messageFade 3s ease;
    }
    .legend-note {
      width: 100%;
      font-size: 0.9rem;
      color: #8a6f4a;
      background: rgba(255, 255, 255, 0.6);
      border: 1px solid rgba(199, 123, 48, 0.2);
      border-radius: 12px;
      padding: 10px 14px;
      line-height: 1.4;
    }
    @keyframes winGlow {
      0% {
        box-shadow: 0 0 6px rgba(255, 223, 120, 0.8);
      }
      50% {
        box-shadow: 0 0 16px rgba(255, 180, 60, 1);
      }
      100% {
        box-shadow: 0 0 6px rgba(255, 223, 120, 0.8);
      }
    }
    @keyframes spin {
      from {
        transform: rotate(0turn);
      }
      to {
        transform: rotate(1turn);
      }
    }
    @keyframes messageFade {
      0% {
        opacity: 0;
        transform: translateY(6px);
      }
      15% {
        opacity: 1;
        transform: translateY(0);
      }
      100% {
        opacity: 0.9;
      }
    }
    @media (max-width: 900px) {
      main.page-wrapper {
        flex-direction: column;
        align-items: center;
      }
      .board-section {
        width: 100%;
      }
      .control-panel {
        width: min(520px, 95%);
        flex: 1 1 auto;
      }
      .button-group button {
        flex: 1 1 100%;
      }
    }
  </style>
</head>
<body>
  <h1>五子棋 · Gomoku</h1>
  <main class="page-wrapper">
    <section class="board-section">
      <div class="board-wrapper">
        <div class="top-row">
          <div class="corner-placeholder"></div>
          <div class="col-labels">
            <span>A</span><span>B</span><span>C</span><span>D</span><span>E</span><span>F</span><span>G</span><span>H</span><span>I</span><span>J</span><span>K</span><span>L</span><span>M</span><span>N</span><span>O</span>
          </div>
        </div>
        <div class="board-row">
          <div class="row-labels">
            <span>1</span><span>2</span><span>3</span><span>4</span><span>5</span><span>6</span><span>7</span><span>8</span><span>9</span><span>10</span><span>11</span><span>12</span><span>13</span><span>14</span><span>15</span>
          </div>
          <div class="board-container">
            <canvas id="board" width="600" height="600" aria-label="五子棋棋盘"></canvas>
          </div>
        </div>
      </div>
    </section>
    <aside class="control-panel">
      <h2>控制面板</h2>
      <p class="legend-note">黑棋：玩家/先手 · 白棋：对手/AI</p>
      <div class="field">
        <label for="modeSelect">对战模式</label>
        <select id="modeSelect">
          <option value="pvai" selected>玩家 vs AI（黑棋先手）</option>
          <option value="pvp">玩家 vs 玩家</option>
        </select>
      </div>
      <div class="button-group">
        <button id="restartBtn">重新开始</button>
        <button id="undoBtn" disabled>悔棋</button>
      </div>
      <div class="status-card">
        <p class="status-row">
          <span class="status-label">当前模式：</span>
          <span class="status-value" id="modeText">玩家 vs AI（玩家执黑）</span>
        </p>
        <p class="status-row">
          <span class="status-label">当前轮到：</span>
          <span class="status-value" id="turnText">黑棋</span>
        </p>
        <p class="status-row">
          <span class="status-label">已下总步数：</span>
          <span class="status-value" id="moveCount">0</span>
        </p>
        <p class="status-row" id="aiStatusRow">
          <span class="status-label">AI 状态：</span>
          <span class="status-value ai-status-wrap" id="aiStatusWrap">
            <span id="aiStatus">等待玩家落子</span>
            <span class="ai-loader" aria-hidden="true"></span>
          </span>
        </p>
        <p class="status-row" id="resultRow">
          <span class="status-label">对局结果：</span>
          <span class="status-value" id="resultText">进行中</span>
        </p>
      </div>
      <div class="message-bar" id="messageArea">提示：点击棋盘任意空交叉点落子。</div>
    </aside>
  </main>
  <script>
    (() => {
      "use strict";

      // ========= 数据结构与状态管理 =========
      // 棋盘使用 15×15 的二维数组，0 表示空位，1 表示黑棋，2 表示白棋
      const BOARD_SIZE = 15;
      const EMPTY = 0;
      const BLACK = 1;
      const WHITE = 2;

      const canvas = document.getElementById("board");
      const ctx = canvas.getContext("2d");
      const modeSelect = document.getElementById("modeSelect");
      const restartBtn = document.getElementById("restartBtn");
      const undoBtn = document.getElementById("undoBtn");
      const modeText = document.getElementById("modeText");
      const turnText = document.getElementById("turnText");
      const moveCountText = document.getElementById("moveCount");
      const aiStatusText = document.getElementById("aiStatus");
      const aiStatusWrap = document.getElementById("aiStatusWrap");
      const resultText = document.getElementById("resultText");
      const resultRow = document.getElementById("resultRow");
      const messageArea = document.getElementById("messageArea");

      /**
       * @typedef {{x:number,y:number,player:number}} MoveStep
       * 历史步列表存储为 {x,y,player} 的顺序数组，用于悔棋与高亮。
       */

      const state = {
        board: createEmptyBoard(),
        currentPlayer: BLACK,
        mode: "pvai",
        moves: /** @type {MoveStep[]} */ ([]),
        gameOver: false,
        winner: null,
        winLine: /** @type {MoveStep[]} */ ([]),
        hoverCell: null,
        aiThinking: false,
        message: "玩家执黑，对战 AI，黑棋先手。",
      };

      const metrics = {
        size: 600,
        padding: 24,
        gap: (600 - 48) / (BOARD_SIZE - 1),
        originX: 24,
        originY: 24,
      };

      init();

      /**
       * @description 初始化应用，绑定事件并渲染初始状态。
       * @returns {void}
       */
      function init() {
        bindEvents();
        resetState("pvai");
        adjustCanvasResolution();
        const resizeObserver = new ResizeObserver(() => adjustCanvasResolution());
        resizeObserver.observe(canvas);
        window.addEventListener("resize", () => adjustCanvasResolution());
      }

      /**
       * @description 创建一个全空的棋盘二维数组。
       * @returns {number[][]} 返回新的棋盘数据。
       */
      function createEmptyBoard() {
        return Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(EMPTY));
      }

      /**
       * @description 将游戏状态重置为初始值。
       * @param {"pvai"|"pvp"} mode 目标模式。
       * @returns {void}
       */
      function resetState(mode) {
        state.mode = mode;
        state.board = createEmptyBoard();
        state.currentPlayer = BLACK;
        state.moves = [];
        state.gameOver = false;
        state.winner = null;
        state.winLine = [];
        state.hoverCell = null;
        state.aiThinking = false;
        const tip = mode === "pvai" ? "已切换为玩家 vs AI 模式，玩家执黑先手。" : "已切换为玩家 vs 玩家模式，双方轮流落子。";
        setMessage(tip);
        updateUI();
        renderBoard();
      }

      /**
       * @description 根据当前窗口尺寸调整 Canvas 像素密度。
       * @returns {void}
       */
      function adjustCanvasResolution() {
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.round(rect.width * dpr);
        canvas.height = Math.round(rect.height * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        renderBoard();
      }

      /**
       * @description 统一更新控制面板的文案与按钮状态。
       * @returns {void}
       */
      function updateUI() {
        modeText.textContent = state.mode === "pvai" ? "玩家 vs AI（玩家执黑）" : "玩家 vs 玩家";
        turnText.textContent = state.gameOver ? "-" : state.currentPlayer === BLACK ? "黑棋" : "白棋";
        moveCountText.textContent = String(state.moves.length);
        if (state.mode === "pvai") {
          if (state.aiThinking) {
            aiStatusText.textContent = "AI 思考中…";
          } else if (state.currentPlayer === WHITE && !state.gameOver) {
            aiStatusText.textContent = "AI 准备落子";
          } else {
            aiStatusText.textContent = "等待玩家落子";
          }
        } else {
          aiStatusText.textContent = "当前为人人对战模式";
        }
        if (aiStatusWrap) {
          aiStatusWrap.classList.toggle("thinking", state.mode === "pvai" && state.aiThinking);
        }
        if (state.gameOver) {
          if (state.winner === BLACK) {
            resultText.textContent = "黑棋获胜！请点击重新开始。";
          } else if (state.winner === WHITE) {
            resultText.textContent = "白棋获胜！请点击重新开始。";
          } else {
            resultText.textContent = "平局，欢迎再来一局。";
          }
        } else {
          resultText.textContent = "进行中";
        }
        if (resultRow) {
          if (state.gameOver && (state.winner === BLACK || state.winner === WHITE)) {
            resultRow.classList.add("is-finished");
          } else {
            resultRow.classList.remove("is-finished");
          }
        }
        messageArea.textContent = state.message;
        undoBtn.disabled = state.moves.length === 0 || state.aiThinking;
      }

      /**
       * @description 设置提示信息文本。
       * @param {string} text 需要展示的内容。
       * @returns {void}
       */
      function setMessage(text) {
        state.message = text;
        messageArea.textContent = text;
        messageArea.classList.remove("message-flash");
        // 触发重绘以重启动画
        void messageArea.offsetWidth;
        messageArea.classList.add("message-flash");
      }

      /**
       * @description 统一绑定页面事件。
       * @returns {void}
       */
      function bindEvents() {
        canvas.addEventListener("click", handleBoardClick);
        canvas.addEventListener("mousemove", handleMouseMove);
        canvas.addEventListener("mouseleave", handleMouseLeave);
        modeSelect.addEventListener("change", (evt) => {
          const newMode = /** @type {"pvai"|"pvp"} */ (evt.target.value);
          resetState(newMode);
        });
        restartBtn.addEventListener("click", () => {
          resetState(state.mode);
          setMessage("棋盘已重置，黑棋先手。" );
        });
        undoBtn.addEventListener("click", handleUndo);
      }

      /**
       * @description 处理玩家点击棋盘的逻辑。
       * @param {MouseEvent} evt 鼠标事件。
       * @returns {void}
       */
      function handleBoardClick(evt) {
        if (state.gameOver) {
          setMessage("对局已结束，请点击重新开始。");
          return;
        }
        if (state.aiThinking) {
          setMessage("AI 正在思考，请稍候。" );
          return;
        }
        if (!isHumanTurn()) {
          setMessage("当前轮到 AI 落子。");
          return;
        }
        const cell = locateCell(evt);
        if (!cell) {
          setMessage("请点击棋盘交叉点附近。" );
          return;
        }
        const placed = placeStone(cell.x, cell.y, state.currentPlayer);
        if (placed && state.mode === "pvai" && !state.gameOver) {
          triggerAIMove();
        }
      }

      /**
       * @description 判断当前是否轮到玩家操作。
       * @returns {boolean} true 表示可以由玩家落子。
       */
      function isHumanTurn() {
        if (state.mode === "pvp") return true;
        return state.currentPlayer === BLACK;
      }

      /**
       * @description 计算鼠标位置对应的棋盘坐标。
       * @param {MouseEvent} evt 鼠标事件。
       * @returns {{x:number,y:number}|null} 若命中交叉点则返回坐标，否则 null。
       */
      function locateCell(evt) {
        const rect = canvas.getBoundingClientRect();
        if (!rect.width || !rect.height) return null;
        const relativeX = ((evt.clientX - rect.left) / rect.width) * metrics.size;
        const relativeY = ((evt.clientY - rect.top) / rect.height) * metrics.size;
        const boardX = (relativeX - metrics.originX) / metrics.gap;
        const boardY = (relativeY - metrics.originY) / metrics.gap;
        const col = Math.round(boardX);
        const row = Math.round(boardY);
        if (col < 0 || col >= BOARD_SIZE || row < 0 || row >= BOARD_SIZE) {
          return null;
        }
        const diffX = Math.abs(boardX - col);
        const diffY = Math.abs(boardY - row);
        if (diffX > 0.35 || diffY > 0.35) return null;
        return { x: col, y: row };
      }

      /**
       * @description 处理鼠标移动用于显示半透明预览。
       * @param {MouseEvent} evt 鼠标事件。
       * @returns {void}
       */
      function handleMouseMove(evt) {
        if (!hoverEnabled()) {
          if (state.hoverCell) {
            state.hoverCell = null;
            renderBoard();
          }
          return;
        }
        const cell = locateCell(evt);
        if (!cell || state.board[cell.y][cell.x] !== EMPTY) {
          if (state.hoverCell) {
            state.hoverCell = null;
            renderBoard();
          }
          return;
        }
        if (!state.hoverCell || state.hoverCell.x !== cell.x || state.hoverCell.y !== cell.y) {
          state.hoverCell = cell;
          renderBoard();
        }
      }

      /**
       * @description 鼠标离开时清理预览。
       * @returns {void}
       */
      function handleMouseLeave() {
        if (state.hoverCell) {
          state.hoverCell = null;
          renderBoard();
        }
      }

      /**
       * @description 判断是否可以显示预览棋子。
       * @returns {boolean} true 表示可以显示预览。
       */
      function hoverEnabled() {
        return !state.gameOver && !state.aiThinking && (state.mode === "pvp" || state.currentPlayer === BLACK);
      }

      /**
       * @description 在指定坐标处落子并处理胜负判定。
       * @param {number} x 列坐标（0-14）。
       * @param {number} y 行坐标（0-14）。
       * @param {number} player 当前落子方。
       * @returns {boolean} true 表示落子成功。
       */
      function placeStone(x, y, player) {
        if (state.board[y][x] !== EMPTY) {
          setMessage("该位置已有棋子，请选择其他交叉点。" );
          return false;
        }
        state.board[y][x] = player;
        state.moves.push({ x, y, player });
        state.currentPlayer = invertPlayer(player);
        const winInfo = checkWin(x, y, player);
        if (winInfo.win) {
          state.gameOver = true;
          state.winner = player;
          state.winLine = winInfo.line;
          setMessage(`${player === BLACK ? "黑棋" : "白棋"} 获胜！请点击重新开始。`);
        } else if (state.moves.length === BOARD_SIZE * BOARD_SIZE) {
          state.gameOver = true;
          state.winner = null;
          state.winLine = [];
          setMessage("棋盘已下满，双方平局。");
        } else {
          setMessage(`轮到 ${state.currentPlayer === BLACK ? "黑棋" : "白棋"}。`);
        }
        updateUI();
        renderBoard();
        return true;
      }

      /**
       * @description 将玩家编号互换。
       * @param {number} player 当前玩家。
       * @returns {number} 对手编号。
       */
      function invertPlayer(player) {
        return player === BLACK ? WHITE : BLACK;
      }

      /**
       * @description 触发 AI 落子，包含思考延迟与策略决策。
       * @returns {void}
       */
      function triggerAIMove() {
        if (state.mode !== "pvai" || state.gameOver) return;
        state.aiThinking = true;
        setMessage("AI 思考中……" );
        updateUI();
        const delay = 250 + Math.random() * 250;
        setTimeout(() => {
          const move = findBestAIMove();
          state.aiThinking = false;
          if (!move) {
            state.gameOver = true;
            state.winner = null;
            setMessage("AI 无法落子，判定为平局。" );
            updateUI();
            renderBoard();
            return;
          }
          const success = placeStone(move.x, move.y, WHITE);
          if (success && !state.gameOver) {
            setMessage("轮到玩家落子。" );
          }
          updateUI();
        }, delay);
      }

      /**
       * @description 根据当前棋局为 AI 选择最佳落点。
       * @returns {{x:number,y:number}|null} 返回落子坐标，若无可落点则 null。
       */
      function findBestAIMove() {
        const candidates = gatherCandidateCells();
        if (!candidates.length) {
          return null;
        }
        for (const cell of candidates) {
          if (willWin(cell.x, cell.y, WHITE)) return cell;
        }
        for (const cell of candidates) {
          if (willWin(cell.x, cell.y, BLACK)) return cell;
        }
        let best = null;
        let bestScore = -Infinity;
        for (const cell of candidates) {
          const score = scoreCell(cell.x, cell.y);
          if (score > bestScore) {
            bestScore = score;
            best = cell;
          }
        }
        return best;
      }

      /**
       * @description 判断在指定位置模拟落子后是否能直接获胜。
       * @param {number} x 列坐标。
       * @param {number} y 行坐标。
       * @param {number} player 棋方。
       * @returns {boolean} true 表示该点可直接五连。
       */
      function willWin(x, y, player) {
        state.board[y][x] = player;
        const result = checkWin(x, y, player).win;
        state.board[y][x] = EMPTY;
        return result;
      }

      /**
       * @description 收集所有优先考虑的空位（靠近已有棋子）。
       * @returns {{x:number,y:number}[]} 候选坐标数组。
       */
      function gatherCandidateCells() {
        if (state.moves.length === 0) {
          return [{ x: 7, y: 7 }];
        }
        const set = new Set();
        for (let y = 0; y < BOARD_SIZE; y++) {
          for (let x = 0; x < BOARD_SIZE; x++) {
            if (state.board[y][x] === EMPTY) continue;
            for (let dy = -2; dy <= 2; dy++) {
              for (let dx = -2; dx <= 2; dx++) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) continue;
                if (state.board[ny][nx] !== EMPTY) continue;
                set.add(`${nx},${ny}`);
              }
            }
          }
        }
        const result = Array.from(set).map((key) => {
          const [x, y] = key.split(",").map(Number);
          return { x, y };
        });
        if (!result.length) {
          for (let y = 0; y < BOARD_SIZE; y++) {
            for (let x = 0; x < BOARD_SIZE; x++) {
              if (state.board[y][x] === EMPTY) {
                result.push({ x, y });
              }
            }
          }
        }
        return result;
      }

      /**
       * @description 针对某个空位计算综合评分（进攻 + 防守 + 中心偏好）。
       * @param {number} x 列坐标。
       * @param {number} y 行坐标。
       * @returns {number} 分值越高越优。
       */
      function scoreCell(x, y) {
        const attack = evaluatePotential(x, y, WHITE);
        const defense = evaluatePotential(x, y, BLACK) * 0.9;
        const centerBias = 10 - Math.hypot(x - 7, y - 7);
        return attack + defense + centerBias;
      }

      /**
       * @description 评估指定玩家在某个空位的连珠潜力。
       * @param {number} x 列坐标。
       * @param {number} y 行坐标。
       * @param {number} player 棋方。
       * @returns {number} 累计得分。
       */
      function evaluatePotential(x, y, player) {
        state.board[y][x] = player;
        let score = 0;
        const dirs = [
          [1, 0],
          [0, 1],
          [1, 1],
          [1, -1],
        ];
        for (const [dx, dy] of dirs) {
          const info = analyzeLine(x, y, dx, dy, player);
          score += patternScore(info.count, info.openEnds);
        }
        state.board[y][x] = EMPTY;
        return score;
      }

      /**
       * @description 统计某方向上连续棋子与两端空位情况。
       * @param {number} x 列坐标。
       * @param {number} y 行坐标。
       * @param {number} dx 方向 X 增量。
       * @param {number} dy 方向 Y 增量。
       * @param {number} player 棋方。
       * @returns {{count:number,openEnds:number}} 返回连珠长度与空端数。
       */
      function analyzeLine(x, y, dx, dy, player) {
        let count = 1;
        let openEnds = 0;
        let step = 1;
        while (true) {
          const nx = x + dx * step;
          const ny = y + dy * step;
          if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) {
            break;
          }
          const val = state.board[ny][nx];
          if (val === player) {
            count++;
            step++;
          } else {
            if (val === EMPTY) openEnds++;
            break;
          }
        }
        step = 1;
        while (true) {
          const nx = x - dx * step;
          const ny = y - dy * step;
          if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) {
            break;
          }
          const val = state.board[ny][nx];
          if (val === player) {
            count++;
            step++;
          } else {
            if (val === EMPTY) openEnds++;
            break;
          }
        }
        return { count, openEnds };
      }

      /**
       * @description 将连珠描述映射为评估得分。
       * @param {number} length 连珠长度。
       * @param {number} openEnds 空端数量。
       * @returns {number} 分值。
       */
      function patternScore(length, openEnds) {
        if (length >= 5) return 100000;
        if (length === 4 && openEnds === 2) return 20000;
        if (length === 4 && openEnds === 1) return 5000;
        if (length === 3 && openEnds === 2) return 1200;
        if (length === 3 && openEnds === 1) return 400;
        if (length === 2 && openEnds === 2) return 200;
        if (length === 2 && openEnds === 1) return 80;
        if (length === 1 && openEnds === 2) return 40;
        return 5;
      }

      /**
       * @description 检测当前落子是否形成五连。
       * @param {number} x 列坐标。
       * @param {number} y 行坐标。
       * @param {number} player 棋方。
       * @returns {{win:boolean,line:MoveStep[]}} 返回胜负与连线坐标。
       */
      function checkWin(x, y, player) {
        const dirs = [
          [1, 0],
          [0, 1],
          [1, 1],
          [1, -1],
        ];
        for (const [dx, dy] of dirs) {
          const line = collectLine(x, y, dx, dy, player);
          if (line.length >= 5) {
            return { win: true, line };
          }
        }
        return { win: false, line: [] };
      }

      /**
       * @description 收集某方向上的连续坐标，用于胜利高亮。
       * @param {number} x 列坐标。
       * @param {number} y 行坐标。
       * @param {number} dx X 方向增量。
       * @param {number} dy Y 方向增量。
       * @param {number} player 棋方。
       * @returns {MoveStep[]} 连续棋子坐标。
       */
      function collectLine(x, y, dx, dy, player) {
        const cells = [{ x, y, player }];
        let step = 1;
        while (true) {
          const nx = x + dx * step;
          const ny = y + dy * step;
          if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
          if (state.board[ny][nx] === player) {
            cells.push({ x: nx, y: ny, player });
            step++;
          } else {
            break;
          }
        }
        step = 1;
        while (true) {
          const nx = x - dx * step;
          const ny = y - dy * step;
          if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) break;
          if (state.board[ny][nx] === player) {
            cells.unshift({ x: nx, y: ny, player });
            step++;
          } else {
            break;
          }
        }
        return cells;
      }

      /**
       * @description 渲染整个棋盘、棋子、预览与高亮。
       * @returns {void}
       */
      function renderBoard() {
        const size = canvas.clientWidth || metrics.size;
        if (!size) return;
        const padding = size * 0.05;
        const gridSize = size - padding * 2;
        const gap = gridSize / (BOARD_SIZE - 1);
        metrics.size = size;
        metrics.padding = padding;
        metrics.gap = gap;
        metrics.originX = padding;
        metrics.originY = padding;

        ctx.clearRect(0, 0, size, size);
        const bg = ctx.createLinearGradient(0, 0, size, size);
        bg.addColorStop(0, "#f8e8c2");
        bg.addColorStop(1, "#f0d3a2");
        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, size, size);

        ctx.strokeStyle = "#8a5a1f";
        ctx.lineWidth = 1;
        for (let i = 0; i < BOARD_SIZE; i++) {
          const pos = padding + i * gap;
          ctx.beginPath();
          ctx.moveTo(padding, pos);
          ctx.lineTo(padding + gridSize, pos);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(pos, padding);
          ctx.lineTo(pos, padding + gridSize);
          ctx.stroke();
        }

        drawStarPoints(padding, gap);

        const lastMove = state.moves[state.moves.length - 1];
        for (let y = 0; y < BOARD_SIZE; y++) {
          for (let x = 0; x < BOARD_SIZE; x++) {
            const val = state.board[y][x];
            if (val === EMPTY) continue;
            const isLast = !!(lastMove && lastMove.x === x && lastMove.y === y);
            const isWinning = state.winLine.some((cell) => cell.x === x && cell.y === y);
            drawStone(x, y, val, isLast, isWinning);
          }
        }

        if (state.hoverCell && hoverEnabled() && state.board[state.hoverCell.y][state.hoverCell.x] === EMPTY) {
          drawHoverStone(state.hoverCell.x, state.hoverCell.y, state.currentPlayer);
        }
      }

      /**
       * @description 绘制星位（天元与四角星）。
       * @param {number} padding 边距。
       * @param {number} gap 网格间距。
       * @returns {void}
       */
      function drawStarPoints(padding, gap) {
        const points = [
          [3, 3],
          [3, BOARD_SIZE - 4],
          [BOARD_SIZE - 4, 3],
          [BOARD_SIZE - 4, BOARD_SIZE - 4],
          [Math.floor(BOARD_SIZE / 2), Math.floor(BOARD_SIZE / 2)],
        ];
        ctx.fillStyle = "#4a2c0a";
        for (const [x, y] of points) {
          const px = padding + x * gap;
          const py = padding + y * gap;
          ctx.beginPath();
          ctx.arc(px, py, gap * 0.12, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      /**
       * @description 绘制单颗棋子及其高亮效果。
       * @param {number} x 列坐标。
       * @param {number} y 行坐标。
       * @param {number} player 棋方。
       * @param {boolean} isLast 是否为最近一步。
       * @param {boolean} isWinning 是否属于胜利连线。
       * @returns {void}
       */
      function drawStone(x, y, player, isLast, isWinning) {
        const gap = metrics.gap;
        const px = metrics.originX + x * gap;
        const py = metrics.originY + y * gap;
        const radius = gap * 0.38;
        ctx.save();
        const gradient = ctx.createRadialGradient(
          px - radius * 0.3,
          py - radius * 0.3,
          radius * 0.2,
          px,
          py,
          radius
        );
        if (player === BLACK) {
          gradient.addColorStop(0, "#615049");
          gradient.addColorStop(1, "#1f140a");
        } else {
          gradient.addColorStop(0, "#ffffff");
          gradient.addColorStop(1, "#cfcfcf");
        }
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(px, py, radius, 0, Math.PI * 2);
        ctx.fill();
        if (isWinning) {
          ctx.strokeStyle = "#ffcf4a";
          ctx.lineWidth = 4;
          ctx.shadowColor = "rgba(255, 207, 74, 0.8)";
          ctx.shadowBlur = 18;
          ctx.stroke();
        }
        if (isLast) {
          ctx.strokeStyle = "rgba(255, 255, 255, 0.85)";
          ctx.lineWidth = 2.5;
          ctx.shadowColor = "rgba(255, 255, 255, 0.6)";
          ctx.shadowBlur = 10;
          ctx.stroke();
        }
        ctx.restore();
      }

      /**
       * @description 绘制半透明的预览棋子。
       * @param {number} x 列坐标。
       * @param {number} y 行坐标。
       * @param {number} player 棋方。
       * @returns {void}
       */
      function drawHoverStone(x, y, player) {
        const gap = metrics.gap;
        const px = metrics.originX + x * gap;
        const py = metrics.originY + y * gap;
        const radius = gap * 0.36;
        ctx.save();
        ctx.globalAlpha = 0.45;
        ctx.fillStyle = player === BLACK ? "#3a2a1b" : "#f8f8f8";
        ctx.beginPath();
        ctx.arc(px, py, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      /**
       * @description 处理悔棋按钮逻辑。
       * @returns {void}
       */
      function handleUndo() {
        if (!state.moves.length) {
          setMessage("暂无可悔的棋步。" );
          return;
        }
        if (state.aiThinking) {
          setMessage("AI 思考中，暂不能悔棋。" );
          return;
        }
        if (state.mode === "pvai") {
          undoOnce();
          if (state.moves.length) {
            undoOnce();
          }
        } else {
          undoOnce();
        }
        state.gameOver = false;
        state.winner = null;
        state.winLine = [];
        state.currentPlayer = state.moves.length ? invertPlayer(state.moves[state.moves.length - 1].player) : BLACK;
        state.hoverCell = null;
        setMessage("已悔棋，请继续对弈。" );
        updateUI();
        renderBoard();
      }

      /**
       * @description 撤销一步棋（内部工具）。
       * @returns {void}
       */
      function undoOnce() {
        const step = state.moves.pop();
        if (!step) return;
        state.board[step.y][step.x] = EMPTY;
      }

    })();
  </script>
</body>
</html>
